/*
Developer:Dhuv Kohli, IIT Guwahati
*******************************************************************************************************
AES API FOR ENCRYPTION AND DECRYPTION {SEE KEY SCEHDULE > CONSTANTS FOR THE SIZE OF KEY, PT & CT SPECS}
*******************************************************************************************************
AES ENCRYPTION AND DECRYPTION SCHEME MANUAL IMPLMENTATION
****************************************************************************
NOTE : For learning purpose only and will not be implmented in any program.
----------------------------------------------------------------------------
High-level description of the algorithm :
-------------------------------------------

KeyExpansion
	round keys are derived from the cipher key using Rijndael's key schedule. 
    AES requires a separate 128-bit round key block for each round plus one more.

InitialRound
	AddRoundKey—each byte of the state is combined with a block of the round key using bitwise xor.
 	
Rounds
	SubBytes—a non-linear substitution step where each byte is replaced with another according to a lookup table.
	ShiftRows—a transposition step where the last three rows of the state are shifted cyclically a certain number of steps.
	MixColumns—a mixing operation which operates on the columns of the state, combining the four bytes in each column.
	AddRoundKey
Final Round (no MixColumns)
	SubBytes
	ShiftRows
	AddRoundKey.


The key schedule
------------------

	**************Constants************
	Since the key schedule for 128-bit, 192-bit, and 256-bit encryption are very similar, with only some constants changed, 
	the following keysize constants are defined here:
	n has a value of 16 for 128-bit keys, 24 for 192-bit keys, and 32 for 256-bit keys
	b has a value of 176 for 128-bit keys, 208 for 192-bit keys, and 240 for 256-bit keys
	(with 128-bit blocks as in AES, it is correspondingly larger for variants of Rijndael with larger block sizes).

	Key schedule description:
	--------------------------

	Rijndael's key schedule is done as follows:
	The first n bytes of the expanded key are simply the encryption key.
	The rcon iteration value i is set to 1
	Until we have b bytes of expanded key, we do the following to generate n more bytes of expanded key:
		We do the following to create 4 bytes of expanded key:
		
		We create a 4-byte temporary variable, t
		We assign the value of the previous four bytes in the expanded key to t
		We perform the key schedule core (see above) on t, with i as the rcon iteration value
		We increment i by 1
		We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key
		
		We then do the following three times to create the next twelve bytes of expanded key:
		We assign the value of the previous 4 bytes in the expanded key to t
		We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key
		
		If we are processing a 256-bit key, we do the following to generate the next 4 bytes of expanded key:
		We assign the value of the previous 4 bytes in the expanded key to t
		We run each of the 4 bytes in t through Rijndael's S-box
		We exclusive-OR t with the 4-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key.

		If we are processing a 128-bit key, we do not perform the following steps.
	    If we are processing a 192-bit key, we run the following steps twice. 
	    If we are processing a 256-bit key, we run the following steps three times:
		We assign the value of the previous 4 bytes in the expanded key to t
		We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key

Key schedule core
-------------------

	This operation is used as an inner loop in the key schedule, and is done in the following manner:
	The input is a 32-bit word and at an iteration number i. The output is a 32-bit word.
	Copy the input over to the output.
	Use the above described rotate operation to rotate the output eight bits to the left
	Apply Rijndael's S-box on all four individual bytes in the output word
	On just the first (leftmost) byte of the output word, exclusive OR the byte with 2 to the power of (i-1).
    In other words, perform the rcon operation with i as the input, and exclusive or the rcon output with the first byte of the output word.

Rcon[256] = {
0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d};

S-Box
----------

   | 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
---|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
00 |63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76 
10 |ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0 
20 |b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15 
30 |04 c7 23 c3 18 96 05 9a 07 12 80 e2 eb 27 b2 75 
40 |09 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84 
50 |53 d1 00 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf 
60 |d0 ef aa fb 43 4d 33 85 45 f9 02 7f 50 3c 9f a8 
70 |51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2 
80 |cd 0c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73 
90 |60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e 0b db 
a0 |e0 32 3a 0a 49 06 24 5c c2 d3 ac 62 91 95 e4 79 
b0 |e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae 08 
c0 |ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a 
d0 |70 3e b5 66 48 03 f6 0e 61 35 57 b9 86 c1 1d 9e 
e0 |e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df 
f0 |8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16 

unsigned char s[256] = 
{
   0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
   0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
   0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
   0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
   0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
   0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
   0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
   0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
   0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
   0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
   0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
   0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
   0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
   0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
   0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
   0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

Inverse S-Box
-------------------

   | 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
---|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
00 |52 09 6a d5 30 36 a5 38 bf 40 a3 9e 81 f3 d7 fb 
10 |7c e3 39 82 9b 2f ff 87 34 8e 43 44 c4 de e9 cb 
20 |54 7b 94 32 a6 c2 23 3d ee 4c 95 0b 42 fa c3 4e 
30 |08 2e a1 66 28 d9 24 b2 76 5b a2 49 6d 8b d1 25 
40 |72 f8 f6 64 86 68 98 16 d4 a4 5c cc 5d 65 b6 92 
50 |6c 70 48 50 fd ed b9 da 5e 15 46 57 a7 8d 9d 84 
60 |90 d8 ab 00 8c bc d3 0a f7 e4 58 05 b8 b3 45 06 
70 |d0 2c 1e 8f ca 3f 0f 02 c1 af bd 03 01 13 8a 6b 
80 |3a 91 11 41 4f 67 dc ea 97 f2 cf ce f0 b4 e6 73 
90 |96 ac 74 22 e7 ad 35 85 e2 f9 37 e8 1c 75 df 6e 
a0 |47 f1 1a 71 1d 29 c5 89 6f b7 62 0e aa 18 be 1b 
b0 |fc 56 3e 4b c6 d2 79 20 9a db c0 fe 78 cd 5a f4 
c0 |1f dd a8 33 88 07 c7 31 b1 12 10 59 27 80 ec 5f 
d0 |60 51 7f a9 19 b5 4a 0d 2d e5 7a 9f 93 c9 9c ef 
e0 |a0 e0 3b 4d ae 2a f5 b0 c8 eb bb 3c 83 53 99 61 
f0 |17 2b 04 7e ba 77 d6 26 e1 69 14 63 55 21 0c 7d 


unsigned char inv_s[256] = 
{
   0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
   0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
   0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
   0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
   0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
   0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
   0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
   0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
   0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
   0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
   0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
   0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
   0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
   0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
   0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
   0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

Rotate
----------
	The rotate operation takes a 32-bit word like this (in hexadecimal):
		1D 2C 3A 4F
	and rotates it eight bits to the left such that the high eight bits "wrap around" and become the low eight bits of the result.
		2C 3A 4F 1D


*/

#include <cstdio>
#include <cstdlib>

using namespace std;

typedef unsigned char byte;

struct word
{
	byte alpha[4];
};

/**********************************************************************************************
S-BOX FORWARD
**********************************************************************************************/
byte s[256] = 
{
   0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
   0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
   0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
   0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
   0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
   0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
   0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
   0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
   0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
   0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
   0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
   0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
   0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
   0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
   0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
   0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

/**********************************************************************************************
S-BOX INVERSE
**********************************************************************************************/
byte inv_s[256] = 
{
   0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
   0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
   0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
   0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
   0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
   0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
   0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
   0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
   0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
   0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
   0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
   0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
   0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
   0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
   0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
   0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

/**********************************************************************************************
RCON BOX
**********************************************************************************************/
byte Rcon[256] = {
0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};


/**********************************************************************************************
S-BOX SUBSTITUTION OF WORD : CHECK == 0 => FORWARD SUB. , CHECK == 1 => INV. SUB.
**********************************************************************************************/
word subWord(word input, int check)
{
	word output;

	if(check == 0)
	{
		for(int i = 0; i < 4; ++i)
		{
			output.alpha[i] = s[(int)input.alpha[i]];
		}
	}
	else
	{
		for(int i = 0; i < 4; ++i)
		{
			output.alpha[i] = inv_s[(int)input.alpha[i]];
		}
	}
	return output;
}

/**********************************************************************************************
ROTATION OF WORD
**********************************************************************************************/
word rotWord(word input)
{
	word output;
	byte temp;

	temp = input.alpha[0];

	for(int i = 0; i < 4 - 1; ++i)
		output.alpha[i] = input.alpha[i + 1];

	output.alpha[3] = temp;           

	return output;
}

/**********************************************************************************************
XOR TWO WORDS
**********************************************************************************************/
word xor_word(word a, word b)
{
	word output;

	for(int i = 0; i < 4; ++i)
	{
		output.alpha[i] = a.alpha[i] ^ b.alpha[i];
	}
	return output;
}

/******************************************************************************
KEY SCHEDULE/EXPANSION
*******************************************************************************/
void keyExpansion(byte key[], word *w,int Nk,int Nb,int Nr)
{

	word temp;
	int i = 0;

	while (i < Nk)
	{
		for(int j = 0; j < 4; ++j)
		{
			w[i].alpha[j] = key[4 * i + j];
		}
   		i = i+1;
    }

	i = Nk;

	while (i < Nb * (Nr + 1))
    {
    	temp = w[i-1];
		if (i % Nk == 0)
		{
			word temp2;
			temp2.alpha[0] = Rcon[i / Nk];
			temp2.alpha[1] = 0x00;
			temp2.alpha[2] = 0x00;
			temp2.alpha[3] = 0x00;

			temp = xor_word(subWord(rotWord(temp), 0), temp2);
		}
		else if (Nk > 6 && i % Nk == 4)
		{
			temp = subWord(temp, 0);
 		}
		
		w[i] = xor_word(w[i-Nk], temp);
		i++;
	}
}

/**********************************************************************************************
ADDING ROUNDKEY
**********************************************************************************************/
void addRoundKey(word state[], word *w,int start,int end)
{
	for(int i = start; i < end + 1; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
			state[i - start].alpha[j] ^= w[i].alpha[j]; 
		}
		
	}
}

/**********************************************************************************************
S-BOX SUBSTITUTION (FORWARD) OF A STATE WHICH IS 4 X 4
**********************************************************************************************/
void subBytes(word state[])
{
	for(int i = 0; i < 4; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
			state[i].alpha[j] = s[(int)state[i].alpha[j]];
		}
	}
}

/**********************************************************************************************
S-BOX SUBSTITUTION (INVERSE) OF A STATE WHICH IS 4 X 4
**********************************************************************************************/
void invSubBytes(word state[])
{
	for(int i = 0; i < 4; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
			state[i].alpha[j] = inv_s[(int)state[i].alpha[j]];
		}
	}
}

/**********************************************************************************************
SHIFT-ROWS
**********************************************************************************************/
void shiftRows(word state[])
{
	byte temp = state[1].alpha[0];

	for(int i = 0; i < 4 - 1; ++i)
	{
		state[1].alpha[i] = state[1].alpha[i + 1];
	}
	state[1].alpha[3] = temp;

	byte temp1 = state[2].alpha[0], temp2 = state[2].alpha[1];
	state[2].alpha[0] = state[2].alpha[2];
	state[2].alpha[1] = state[2].alpha[3];
	state[2].alpha[2] = temp1;
	state[2].alpha[3] = temp2;

	temp = state[3].alpha[3];
	for(int i = 3; i > 0; --i)
	{
		state[3].alpha[i] = state[3].alpha[i - 1];
	}
	state[3].alpha[0] = temp;
}

/**********************************************************************************************
SHIFT-ROWS INVERSE
**********************************************************************************************/
void invShiftRows(word state[])
{
	byte temp = state[3].alpha[0];

	for(int i = 0; i < 4 - 1; ++i)
	{
		state[3].alpha[i] = state[3].alpha[i + 1];
	}
	state[3].alpha[3] = temp;

	byte temp1 = state[2].alpha[0], temp2 = state[2].alpha[1];
	state[2].alpha[0] = state[2].alpha[2];
	state[2].alpha[1] = state[2].alpha[3];
	state[2].alpha[2] = temp1;
	state[2].alpha[3] = temp2;

	temp = state[1].alpha[3];
	for(int i = 3; i > 0; --i)
	{
		state[1].alpha[i] = state[1].alpha[i - 1];
	}
	state[1].alpha[0] = temp;
}

/**********************************************************************************************
MULTIPLY BY 2 I.E. 0x02 * a 
**********************************************************************************************/
byte multiplyBy2(byte a)
{
	byte a1;
	if(a << 1 > 0xFF)
		a1 = (a << 1) ^ 0x1b;
	else 
		a1 = a << 1;

	return a1;
}

/**********************************************************************************************
MULTIPLY BY 3 I.E. 0x03 * a
**********************************************************************************************/
byte multiplyBy3(byte a)
{
	byte a1;
	if(a << 1 > 0xFF)
		a1 = (a << 1) ^ 0x1b;
	else 
		a1 = a << 1;

	return a1^a;
}

/**********************************************************************************************
MIXING - COLUMNS
**********************************************************************************************/
void mixColumns(word state[])
{
	word temp[4];
	byte a , b, c, d, a1, b1, c1, d1;

	for(int i = 0; i < 4; ++i)
	{
		a = state[0].alpha[i];
		b = state[1].alpha[i];
		c = state[2].alpha[i];
		d = state[3].alpha[i];

		a1 = multiplyBy2(a);
		b1 = multiplyBy3(b);
		c1 = c;
		d1 = d;

		temp[0].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		b1 = multiplyBy2(b);
		c1 = multiplyBy3(c);
		a1 = a;
		d1 = d;

		temp[1].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		c1 = multiplyBy2(c);
 		d1 = multiplyBy3(d);
		a1 = a;
		b1 = b;

		temp[2].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		d1 = multiplyBy2(d);
		a1 = multiplyBy3(a);
		c1 = c;
		b1 = b;

		temp[3].alpha[i] = a1 ^ b1 ^ c1 ^ d1;
	}
	
	for(int i = 0; i < 4; ++i)
		for(int j = 0; j < 4; ++j)
			state[i].alpha[j] = temp[i].alpha[j];

}

/**********************************************************************************************
MULTIPLY BY 9/11/13/14
**********************************************************************************************/
byte multiplyBy(byte a, int z)
{
	if(z == 9)
		return (multiplyBy2(multiplyBy2(multiplyBy2(a)))) ^ a;
	if(z == 11)
		return multiplyBy2((multiplyBy2(multiplyBy2(a))) ^ a) ^ a;
	if(z == 13)
		return multiplyBy2(multiplyBy2((multiplyBy2(a)) ^ a)) ^ a;
	if(z == 14)
	    return multiplyBy2((multiplyBy2((multiplyBy2(a)) ^ a)) ^ a);

	return 0x00;
}

/**********************************************************************************************
INVERSE-MIXING-COLUMNS
**********************************************************************************************/
void invMixColumns(word state[])
{
	word temp[4];
	byte a , b, c, d, a1, b1, c1, d1;

	for(int i = 0; i < 4; ++i)
	{
		a = state[0].alpha[i];
		b = state[1].alpha[i];
		c = state[2].alpha[i];
		d = state[3].alpha[i];

		a1 = multiplyBy(a, 14);
		b1 = multiplyBy(b, 11);
		c1 = multiplyBy(c, 13);
		d1 = multiplyBy(d, 9);

		temp[0].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		a1 = multiplyBy(a, 9);
		b1 = multiplyBy(b, 14);
		c1 = multiplyBy(c, 11);
		d1 = multiplyBy(d, 13);

		temp[1].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		a1 = multiplyBy(a, 13);
		b1 = multiplyBy(b, 9);
		c1 = multiplyBy(c, 14);
		d1 = multiplyBy(d, 11);

		temp[2].alpha[i] = a1 ^ b1 ^ c1 ^ d1;

		a1 = multiplyBy(a, 11);
		b1 = multiplyBy(b, 13);
		c1 = multiplyBy(c, 9);
		d1 = multiplyBy(d, 14);

		temp[3].alpha[i] = a1 ^ b1 ^ c1 ^ d1;
	}
	
	for(int i = 0; i < 4; ++i)
		for(int j = 0; j < 4; ++j)
			state[i].alpha[j] = temp[i].alpha[j];

}

/**********************************************************************************************
BLOCK-ENCRYPTION-AES
**********************************************************************************************/
void blockEncryptionAes(byte in[], byte *out, word *w,int Nb,int Nr,int Nk)
{

	word state[4];

	for(int i = 0; i < 4; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
			state[j].alpha[i] = in[4 * i + j];        
		}
	}

	addRoundKey(state, w, 0, Nb - 1);
	
	for(int rnd = 1; rnd < Nr; ++rnd)
	{
		subBytes(state);
		shiftRows(state);
		mixColumns(state);
		addRoundKey(state, w, rnd*Nb, (rnd + 1) * Nb - 1);
	}

	subBytes(state);
	shiftRows(state);
 
	addRoundKey(state, w, Nr*Nb, (Nr + 1) * Nb - 1);

	for(int i = 0; i < 4; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
		    out[4 * i + j] = state[j].alpha[i];
		}
	}
}

/**********************************************************************************************
BLOCK-DECRYPTION-AES
**********************************************************************************************/
void blockDecryptionAes(byte in[], byte *out, word *w, int Nb, int Nr, int Nk)
{

	word state[4];

		for(int i = 0; i < 4; ++i)
		{
			for(int j = 0; j < 4; ++j)
			{
				state[j].alpha[i] = in[4 * i + j];        
			}
		}

	addRoundKey(state, w, Nr*Nb, (Nr+1)*Nb-1);

	for(int rnd = Nr-1; rnd > 0; --rnd)
    {
		invShiftRows(state);
		invSubBytes(state);
		addRoundKey(state, w, rnd*Nb, (rnd+1)*Nb-1);
		invMixColumns(state);           
	}

	invShiftRows(state);
	invSubBytes(state);
	addRoundKey(state, w, 0, Nb-1);

	for(int i = 0; i < 4; ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
		    out[4 * i + j] = state[j].alpha[i];
		}
	}
}

/**********************************************************************************************
AES-ENCRYPTION CALLING FUNCTION
**********************************************************************************************/
byte* aesEncryption(byte key[], byte plain[], int Nk, int Nb, int Nr)
{
	byte *out = (byte *) malloc((4 * Nb) * sizeof(byte));
	word *w = (word *) malloc(Nb * (Nr + 1) * sizeof(word));
	word *expanded_key = (word *) malloc(Nb * (Nr + 1) * sizeof(word));

	keyExpansion(key, w, Nk, Nb, Nr);

	for(int i = 0; i < Nb * (Nr + 1); ++i)
	{
			for(int j = 0; j < 4; ++j)
		{
			expanded_key[i].alpha[j] = w[(i / Nb) * Nb + j].alpha[i % Nb];
		}		
	}
	blockEncryptionAes(plain, out, expanded_key, Nb, Nr, Nk);

	return out;
}

/**********************************************************************************************
AES-DECRYPTION CALLING FUNCTION
**********************************************************************************************/
byte* aesDecryption(byte key[], byte cipher[], int Nk, int Nb, int Nr)
{
	byte *out = (byte *) malloc((4 * Nb) * sizeof(byte));
	word *w = (word *) malloc(Nb * (Nr + 1) * sizeof(word));
	word *expanded_key = (word *) malloc(Nb * (Nr + 1) * sizeof(word));

	keyExpansion(key, w, Nk, Nb, Nr);

	for(int i = 0; i < Nb * (Nr + 1); ++i)
	{
		for(int j = 0; j < 4; ++j)
		{
			expanded_key[i].alpha[j] = w[(i / Nb) * Nb + j].alpha[i % Nb];
		}		
	}

	blockDecryptionAes(cipher, out, expanded_key, Nb, Nr, Nk);

	return out;
}


#if 1
/*************************************************************************************************************
For testing purpose only
*************************************************************************************************************/

int main()
{
	byte key[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
	byte plain[] = {0x69,0xc4,0xe0,0xd8,0x6a,0x7b,0x04,0x30,0xd8,0xcd,0xb7,0x80,0x70,0xb4,0xc5,0x5a};
	byte *out = NULL;
	char *keyString, *plainText;
	int Nk, Nb, Nr;

	printf("Enter Values of Nk, Nb, Nr : ");
	scanf("%d%d%d", &Nk, &Nb, &Nr);

	

    out = aesEncryption(key, plain, Nk, Nb, Nr);

	for(int i = 0; i < 16; ++i)
	{
		printf("%x", out[i]);
	}
	printf("\n");


	return 0;
}
#endif

